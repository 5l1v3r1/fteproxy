#!/usr/bin/env python
# -*- coding: utf-8 -*-

# This file is part of FTE.
#
# FTE is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# FTE is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with FTE.  If not, see <http://www.gnu.org/licenses/>.


import sys
import os
import signal
import glob
import argparse
import threading

from twisted.internet import reactor

sys.path.append(
    os.path.abspath(os.path.join(os.path.dirname(os.path.realpath(__file__)), '..')))

import fte.conf
import fte.socks
import fte.socks.managed
import fte.server
import fte.client
import fte.client.managed

FTE_PT_NAME = 'fte'

class FTEMain(threading.Thread):

    def __init__(self, args):
        threading.Thread.__init(self)
        self._args = args

    def run(self):
        self._client = None
        self._server = None

        if not self._args.quiet and not self._args.managed:
            print """FTE Copyright (C) 2012-2013 Kevin P. Dyer <kdyer@cs.pdx.edu>
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it under certain conditions.
"""

        if self._args.mode == 'test':
            test()
            sys.exit(0)
        if self._args.stop:
            if not self._args.mode:
                print '--mode keyword is required with --stop'
                parser.print_help()
                sys.exit(1)
            if self._args.mode in ['client', 'server']:
                pid_files_path = \
                    os.path.join(fte.conf.getValue('general.pid_dir'),
                                 '.' + self._args.mode + '-*.pid')
                pid_files = glob.glob(pid_files_path)
                for pid_file in pid_files:
                    with open(pid_file) as f:
                        pid = int(f.read())
                        try:
                            os.kill(pid, signal.SIGKILL)
                        except OSError:
                            pass
                        os.unlink(pid_file)
                sys.exit(0)
        if self._args.mode == 'client':
            fte.conf.setValue('runtime.mode', 'client')
        elif self._args.mode == 'server':
            fte.conf.setValue('runtime.mode', 'server')
        else:
            parser.print_help()
            sys.exit(1)
        if self._args.client_ip:
            fte.conf.setValue('runtime.client.ip', self._args.client_ip)
        if self._args.client_port:
            fte.conf.setValue('runtime.client.port',
                              int(self._args.client_port))
        if self._args.server_ip:
            fte.conf.setValue('runtime.server.ip', self._args.server_ip)
        if self._args.server_port:
            fte.conf.setValue('runtime.server.port',
                              int(self._args.server_port))
        if self._args.proxy_ip:
            fte.conf.setValue('runtime.proxy.ip', self._args.proxy_ip)
        if self._args.proxy_port:
            fte.conf.setValue('runtime.proxy.port',
                              int(self._args.proxy_port))
        if self._args.downstream_format:
            fte.conf.setValue('runtime.state.downstream_language',
                              self._args.downstream_format)
        if self._args.upstream_format:
            fte.conf.setValue('runtime.state.upstream_language',
                              self._args.upstream_format)
        if self._args.key:
            if len(self._args.key) != 64:
                print 'Invalid key length: ' + str(len(self._args.key)) + ', should be 64'
                sys.exit(1)
            try:
                binary_key = self._args.key.decode('hex')
            except:
                print 'Invalid key format, must contain only 0-9a-fA-F'
                sys.exit(1)
            fte.conf.setValue('runtime.fte.encrypter.key', binary_key)

        pid_file = os.path.join(fte.conf.getValue('general.pid_dir'),
                                '.' + fte.conf.getValue('runtime.mode')
                                + '-' + str(os.getpid()) + '.pid')

        with open(pid_file, 'w') as f:
            f.write(str(os.getpid()))
        
        if fte.conf.getValue('runtime.mode') == 'client':
            incoming_regex = fte.defs.getRegex(self._args.downstream_format)
            incoming_max_len = fte.defs.getMaxLen(self._args.downstream_format)
            fte.encoder.RegexEncoder(incoming_regex, incoming_max_len)
            outgoing_regex = fte.defs.getRegex(self._args.upstream_format)
            outgoing_max_len = fte.defs.getMaxLen(self._args.upstream_format)
            fte.encoder.RegexEncoder(outgoing_regex, outgoing_max_len)

            if self._args.managed:
                from pyptlib.client import ClientTransportPlugin
                from pyptlib.config import EnvError
                
                client = ClientTransportPlugin()
                try:
                    client.init([FTE_PT_NAME])
                except EnvError, err:
                    print "pyptlib could not bootstrap ('%s')." % str(err)
                    sys.exit(1)
            
                for transport in client.getTransports():
                    if transport == FTE_PT_NAME:
                        local_ip = fte.conf.getValue('runtime.client.ip')
                        local_port = fte.conf.getValue('runtime.client.port')
                        proxy_ip = fte.conf.getValue('runtime.proxy.ip')
                        proxy_port = fte.conf.getValue('runtime.proxy.port')
                        socks_version = 'socks4'
                        factory = fte.socks.managed.SOCKSv4Factory(str(proxy_ip), int(proxy_port))
                        addrport = reactor.listenTCP(local_port, factory, interface=local_ip)
                        client.reportMethodSuccess(transport, socks_version, (addrport.getHost().host, addrport.getHost().port), None, None)
                    else:
                        client.reportFailure(transport, "Failed to launch ('%s')." % "We don't support transport "+transport)
                        
                client.reportMethodsEnd()
                reactor.run()
            else:
    
                if not self._args.quiet:
                    print 'Client ready!'
                
                local_ip = fte.conf.getValue('runtime.client.ip')
                local_port = fte.conf.getValue('runtime.client.port')
                remote_ip = fte.conf.getValue('runtime.server.ip')
                remote_port = fte.conf.getValue('runtime.server.port')
                self._client = fte.client.listener(local_ip, local_port,
                                                   remote_ip, remote_port)
                self._client.daemon = True
                self._client.start()
                self._client.join()
        elif fte.conf.getValue('runtime.mode') == 'server':

            languages = fte.defs.load_definitions()
            for language in languages.keys():
                regex = fte.defs.getRegex(language)
                max_len = fte.defs.getMaxLen(language)
                fte.encoder.RegexEncoder(regex, max_len)

            if self._args.managed:
                from pyptlib.server import ServerTransportPlugin
                from pyptlib.config import EnvError
                
                server = ServerTransportPlugin()
                try:
                    server.init([FTE_PT_NAME])
                except EnvError, err:
                    print "pyptlib could not bootstrap ('%s')." % str(err)
                    sys.exit(1)
            
                for transport, transport_bindaddr in server.getBindAddresses().items():
                    if transport == FTE_PT_NAME:
                        local_ip = transport_bindaddr[0]
                        if transport_bindaddr[1] == 0:
                            local_port = fte.conf.getValue('runtime.server.port')
                        else:
                            local_port = transport_bindaddr[1]
                        remote_ip = fte.conf.getValue('runtime.proxy.ip')
                        remote_port = fte.conf.getValue('runtime.proxy.port')
                        fte.client.managed.DummyTransport(None)
                        bind_addrport = (local_ip, local_port)
                        server.reportMethodSuccess(transport, bind_addrport, None)
                    else:
                        server.reportFailure(transport, "Failed to launch ('%s')." % "We don't support transport "+transport)
                    
                server.reportMethodsEnd()
            else:
                local_ip = fte.conf.getValue('runtime.server.ip')
                local_port = fte.conf.getValue('runtime.server.port')
                remote_ip = fte.conf.getValue('runtime.proxy.ip')
                remote_port = fte.conf.getValue('runtime.proxy.port')
                self._server = fte.server.listener(local_ip, local_port,
                                                   remote_ip, remote_port)
                self._server.daemon = True
                self._server.start()
                if not self._args.quiet:
                    print 'Server ready!'
                self._server.join()

    def stop(self):
        if self._client is not None:
            self._client.stop()
        if self._server is not None:
            self._server.stop()


def test():
    import unittest

    import fte.tests.encoder
    import fte.tests.encrypter
    import fte.tests.record_layer
    import fte.tests.bit_ops
    import fte.tests.relay
    import fte.tests.dfa
    import fte.tests.cDFA

    suite_encoder = unittest.TestLoader().loadTestsFromTestCase(
        fte.tests.encoder.TestEncoders)
    suite_encrypter = unittest.TestLoader().loadTestsFromTestCase(
        fte.tests.encrypter.TestEncoders)
    suite_record_layer = unittest.TestLoader().loadTestsFromTestCase(
        fte.tests.record_layer.TestEncoders)
    suite_relay = unittest.TestLoader().loadTestsFromTestCase(
        fte.tests.relay.TestRelay)
    suite_bit_ops = unittest.TestLoader().loadTestsFromTestCase(
        fte.tests.bit_ops.TestEncoders)
    suite_dfa = unittest.TestLoader().loadTestsFromTestCase(
        fte.tests.dfa.TestDFA)
    suite_cdfa = unittest.TestLoader().loadTestsFromTestCase(
        fte.tests.cDFA.TestcDFA)
    suites = [
        suite_bit_ops,
        suite_encoder,
        suite_encrypter,
        suite_relay,
        suite_record_layer,
        suite_dfa,
        suite_cdfa,
    ]
    alltests = unittest.TestSuite(suites)
    unittest.TextTestRunner(verbosity=2, failfast=True).run(alltests)


def get_args():
    parser = argparse.ArgumentParser(prog='fteproxy',
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--mode',
                        default='client',
                        metavar='(client|server|test)',
                        help='Relay mode: client or server')
    parser.add_argument('--stop', action='store_true',
                        help='Shutdown daemon process')
    parser.add_argument('--upstream-format',
                        help='Client-to-server language format',
                        default=fte.conf.getValue('runtime.state.upstream_language'
                                                  ))
    parser.add_argument('--downstream-format',
                        help='Server-to-client language format',
                        default=fte.conf.getValue('runtime.state.downstream_language'
                                                  ))
    parser.add_argument('--client_ip',
                        help='Client-side listening IP',
                        default=fte.conf.getValue('runtime.client.ip'
                                                  ))
    parser.add_argument('--client_port',
                        help='Client-side listening port',
                        default=fte.conf.getValue('runtime.client.port'
                                                  ))
    parser.add_argument('--server_ip',
                        help='Server-side listening IP',
                        default=fte.conf.getValue('runtime.server.ip'
                                                  ))
    parser.add_argument('--server_port',
                        help='Server-side listening port',
                        default=fte.conf.getValue('runtime.server.port'
                                                  ))
    parser.add_argument('--proxy_ip',
                        help='Forwarding-proxy (SOCKS) listening IP',
                        default=fte.conf.getValue('runtime.proxy.ip'
                                                  ))
    parser.add_argument('--proxy_port',
                        help='Forwarding-proxy (SOCKS) listening port',
                        default=fte.conf.getValue('runtime.proxy.port'
                                                  ))
    parser.add_argument('--quiet', action='store_true', default=False)
    parser.add_argument('--managed',
                        help="Start in managed mode, for use with Tor. --server paramters ignored.",
                        action='store_true',
                        default=False)
    parser.add_argument('--key',
                        help='Cryptographic key, hex, must be exactly 64 characters',
                        default=fte.conf.getValue('runtime.fte.encrypter.key'
                                                  ))
    args = parser.parse_args(sys.argv[1:])

    return args


def main():
    global running

    try:
        args = get_args()
        main = FTEMain(args)
        if args.managed and args.mode=="client":
            main.run()
        else:
            main.daemon = True
            main.start()
            while running and main.is_alive():
                main.join(0.01)
            main.stop()
    except KeyboardInterrupt:
        pass
    finally:
        if fte.conf.getValue('runtime.mode'):
            pid_file = os.path.join(fte.conf.getValue('general.pid_dir'
                                                      ), '.'
                                    + fte.conf.getValue('runtime.mode')
                                    + '-' + str(os.getpid()) + '.pid')
            if pid_file and os.path.exists(pid_file):
                os.unlink(pid_file)


if __name__ == '__main__':
    running = True

    def signal_handler(signal, frame):
        global running
        running = False
    signal.signal(signal.SIGINT, signal_handler)

    main()
