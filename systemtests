#!/usr/bin/env python
# -*- coding: utf-8 -*-

# This file is part of FTE.
#
# FTE is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# FTE is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with FTE.  If not, see <http://www.gnu.org/licenses/>.

# TODO: Change test to not be dependent upon remote server

import os
import time

import fte.defs


BIND_IP = '127.0.0.1'
URL = "https://google.com/"


def main():
    print 'System tests:'
    
    os.system("fteproxy --quiet --mode server" \
                    + " --server_ip " + BIND_IP + " --server_port 8080" \
                    + " --proxy_ip " + BIND_IP + "  --proxy_port 8081 &")
    time.sleep(30)
    
    languages = fte.defs.load_definitions().keys()
    for language in languages:
        if language.endswith('request'):
            format = language[:-8]
            print doTest(format), format
            
    os.system("fteproxy --quiet --mode server --stop")


def sanityCheck():
    assert which("fstminimize") is not None, ("openfst not properly installed")
    assert which("fstprint") is not None, ("openfst not properly installed")
    assert which("fstcompile") is not None, ("openfst not properly installed")
    assert which("fteproxy") is not None, ("fteproxy not properly installed, did you run 'sudo make install'?")
    assert which("socksproxy") is not None, ("socksproxy not properly installed, did you run 'sudo make install'?")


def doTest(format):
    try:
        killall()
        sanityCheck()
        
        os.system("fteproxy --quiet --mode client" \
                        + " --upstream-format " + format + "-request" \
                        + " --downstream-format " + format + "-response" \
                        + " --client_ip " + BIND_IP + " --client_port 8079" \
                        + " --server_ip " + BIND_IP + " --server_port 8080 &")
        os.system("socksproxy --ip " + BIND_IP + " --port 8081 &")
    
        time.sleep(5)
    
        withoutfte = ".withoutfte.txt"
        withfte = ".withfte.txt"
        
        os.system("curl -s "+URL+" > " + withoutfte)
        start = time.time()
        os.system("curl -s --socks4 " + BIND_IP + ":8079 "+URL+" > " + withfte)
        elapsed = time.time() - start
    
        if filesAreEquivalent(withoutfte, withfte):
            retval = "SUCCESS! " + str(elapsed)
        else:
            retval = "FAILED :("
    
        os.unlink(withoutfte)
        os.unlink(withfte)
    finally:
        killall()
    
    return retval


def killall():
    os.system("fteproxy --quiet --mode client --stop")
    os.system("sudo pkill -9 -f socksproxy > /dev/null 2> /dev/null")
    os.system("rm -f socks.log")


def filesAreEquivalent(fileA, fileB):
    with open(fileA) as fh:
        contentsFileA = fh.read()
    with open(fileB) as fh:
        contentsFileB = fh.read()
    assert contentsFileA != ''
    assert contentsFileB != ''
    return (contentsFileA == contentsFileB)


def which(program):
    def is_exe(fpath):
        isFile = os.path.isfile(fpath)
        isExecutable = os.access(fpath, os.X_OK)
        return isFile and isExecutable
    
    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            path = path.strip('"')
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file

    return None


if __name__ == '__main__':
    main()
